
class Ant {
public:
	Ant(Graph& graph) 
		:graph(graph) 
	{
		tour = std::vector<int>(graph.getNumberOfCities() + 1);

		// Initalise Random Number Generator
		std::random_device dev;
		gen = std::mt19937(dev());
		dis = std::uniform_real_distribution<>(0.0, 1.0);

		numberOfCitiesVisited = 0;
	}

	void randomWalk(SquareMatrix& pheremoneMatrix) {
		// Choose Random Node to start at.
		tour[0] = rand() % graph.getNumberOfCities() + 1;
		numberOfCitiesVisited = 1;


		while (numberOfCitiesVisited < graph.getNumberOfCities()) { // Whilst Last City is still not actually our tour
			tour[numberOfCitiesVisited] = chooseNextNode(pheremoneMatrix);
			numberOfCitiesVisited++;
		}

		tour[numberOfCitiesVisited] = tour[0]; // Make the tour cyclic.
	}
	void reset() {
		std::fill(tour.begin(), tour.end(), 0);
		numberOfCitiesVisited = 0;
	}

	bool travelledAlong(int c1, int c2) {
		for (auto i = 0; i < graph.getNumberOfCities(); i++) {
			if (tour[i] == c1 && tour[i + 1] == c2) return true;
		}

		return false;
	}

	int getTourLength() {
		auto sum = 0;

		for (auto i = 0; i < graph.getNumberOfCities(); i++) {
			sum += graph.getWeight(tour[i], tour[i + 1]);
		}

		return sum;
	}

private:

	int chooseNextNode(SquareMatrix& pheremoneMatrix) {
		auto currentCity = getCurrentCity();

		if (dis(gen) <= 0.3) { // Arbituary Limit to stop unneccesary ant exploration, we choose the city deterministically
			return findCityWithLargestPheremone(pheremoneMatrix, currentCity);
		}

		auto p = dis(gen);
		auto unvisitedNeighbours = getUnvisitedNeighbours(currentCity);

		for (auto neighbour : unvisitedNeighbours) {
			p -= caluclateProbabilty(pheremoneMatrix, unvisitedNeighbours, currentCity, neighbour);

			if (p < 0) {
				return neighbour;
			}
		}

		std::cout << "Couldn't choose a neighbour!" << std::endl;
		return unvisitedNeighbours[0];
	}

	inline int getCurrentCity() {
		return tour[numberOfCitiesVisited - 1];
	}

	double caluclateProbabilty(SquareMatrix& pheremoneMatrix, const std::vector<int>& unvisitedNeighbours,
		int currentCity, int neighbour) 
	{
		if (currentCity == neighbour) {
			return 0;
		}

		double pheremoneTerm = pow(pheremoneMatrix.get(currentCity, neighbour), alpha);
		double distance = 1 / graph.getWeight(currentCity, neighbour);
		double distanceTerm = pow(pheremoneTerm, beta);

		double normalisationTerm = 0;
		for (auto s : unvisitedNeighbours) {
			double pherTerm = pow(pheremoneMatrix.get(currentCity, s), alpha);
			double distTerm = pow(graph.getWeight(currentCity, s), beta);

			normalisationTerm += (pherTerm*distTerm);
		}

		return (pheremoneTerm + distanceTerm) / normalisationTerm;
	}

	int findCityWithLargestPheremone(SquareMatrix& pheremoneMatrix, int current) {
		double pheremone = -1;
		int city;
		for (auto c = 1; c <= graph.getNumberOfCities(); c++) {
			auto p = pheremoneMatrix.get(current, c);
			if (p >= pheremone) {
				pheremone = p;
				city = c;
			}
		}
		return city;
	}

	bool vectorContains(std::vector<int> numbers, int val) {
		for (auto v : numbers) {
			if (v == val) {
				return true;
			}
		}
		return false;
	}

	std::vector<int> getUnvisitedNeighbours(int currentCity) {
		auto neighbours = std::vector<int>(graph.getNumberOfCities() - numberOfCitiesVisited);

		int found = 0;
		for (auto city = 1; city <= graph.getNumberOfCities(); city++) {
			if (!vectorContains(tour, city)) {
				neighbours[found] = city;
				found++;
			}
		}
		
		return neighbours;
	}

	Graph& graph;
	std::vector<int> tour;
	int numberOfCitiesVisited;

	// Random Number Generator Stuff
	std::mt19937 gen;
	std::uniform_real_distribution<> dis;
};

auto createPheremoneMatrix(int dimension) {
	SquareMatrix pheremoneMatrix(dimension, DefualtPheremone);

	for (auto city = 1; city <= dimension; city++)
		pheremoneMatrix.set(city, city, 0);

	return pheremoneMatrix;
}

std::vector<Ant*> createAnts(Graph& g) {
	auto result = std::vector<Ant*>(NumberOfAnts);

	for (auto i = 0; i < NumberOfAnts; i++) {
		result[i] = new Ant(g);
	}

	return result;
}

void resetAnts(std::vector<Ant*>& ants) {
	for (auto ant : ants) {
		ant->reset();
	}
}

void walkAnts(std::vector<Ant*>& ants, SquareMatrix& pheremoneMatrix) {
	for (auto ant : ants) {
		ant->randomWalk(pheremoneMatrix);
	}
}

double calculateChangeInPheremone(std::vector<Ant*> ants, SquareMatrix& pheremoneMatrix, int c1, int c2) {
	double change = 0;
	for (auto ant : ants) {
		if (ant->travelledAlong(c1, c2)) {
			change += Q / ant->getTourLength();
		}
	}
	return change;
}

void updatePheremone(Graph& g,std::vector<Ant*>& ants, SquareMatrix pheremoneMatrix) {
	for (auto c1 = 1; c1 <= g.getNumberOfCities(); c1++) {
		for (auto c2 = 1; c2 <= g.getNumberOfCities(); c2++) {
			if (c1 == c2) continue;

			double changeInPheremone = calculateChangeInPheremone(ants, pheremoneMatrix, c1, c2);

			pheremoneMatrix.set(c1, c2, EvaporationFactor*pheremoneMatrix.get(c1, c2) + changeInPheremone);
		}
	}
}

std::vector<int> ACOMk2::solve(Graph g) {
	SquareMatrix pheremoneMatrix = createPheremoneMatrix(g.getNumberOfCities());

	auto ants = createAnts(g);

	pheremoneMatrix.print();
	resetAnts(ants);
	walkAnts(ants, pheremoneMatrix);
	updatePheremone(g, ants, pheremoneMatrix);
	pheremoneMatrix.print();

	return std::vector<int>();
}

ACOMk2::ACOMk2(){}
ACOMk2::~ACOMk2(){}